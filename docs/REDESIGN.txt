- Move int -> byte casting into the AST rather than outputting them during code gen
- Type check arithmetic operators (more generally, define operator rules better or more succinctly)
- Track current stack alignment in the code generator so as to minimise superfluous push/pop/addq/subq
- Move invokeDynamic() into Clara. It would look something like this:

fn invokeDynamic(ptr : int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int) {
    if ptr.isClosure() {
        cl := ptr.toClosure()
        cl.f(c.env, arg1, arg2, arg3, arg4, arg5)
    } else {
        f := ptr.toFunction()
        f(arg1, arg2, arg3, arg4, arg5)
    }
}

struct closure {
    f: fn(env, int, int, int, int, int)
    env: int
}

// External functions
fn isClosure(ptr: int) bool                           // Test GC header for readonly
fn toClosure(ptr: int) cl                             // CAST
fn toFunction(ptr: int) fn(int, int, int, int, int)   // CAST

The important part is to make sure the AST rewrite does not try to wrap c.f(...) in an invokeDynamic call!

- GC tracing of closures can be made more efficient by updating "genClosureGc" to _mark_ the closure pointer & instead
store the address of the _environment_ struct before the function pointer.
- Support reuse of closure env & cl structs
- Support indentation when debugging GC tracing. For example, given the following debug output for marking:

ðŸ”Ž Mark:

main()
  - (0x100100340) 'x'
  - (0x1000033ea) 'string'
  - (0x1000033c5) 'string'
  - (0x100102740) 'windowEvent'
  - (0x1000033fd) 'string'
  - (0x1000033d8) 'string'

What we would actually like to see is something like the following:

ðŸ”Ž Mark:

main()
  - (0x100100340) 'x'
     - (0x1000033ea) 'string'
     - (0x1000033c5) 'string'
  - (0x100102740) 'windowEvent'
     - (0x1000033fd) 'string'
     - (0x1000033d8) 'string'

This clearly shows that 'x' is a struct or enum containing two strings which have been also traced.