// Linked List of all stack frames up to stack base
struct frame {
    next: frame
    map: gcMap
}

fn slot(f: frame, off: byte) pointer = unsafe(f, -off * 8, type(pointer))

// GC roots at a particular point in a stack frame
struct gcMap {
    roots: []byte
}

// Runtime information
struct runtime {
    args: []string
    env: env
}

// C -> Clara entrypoint
#[ExtRet]
fn entrypoint(argc: int, argv: pointer, envp: pointer) {
    setStackBase(getFramePointer())

    // Configure runtime
    setRuntime(Runtime(parseArgs(argc, argv), parseEnv(envp)))

    main() // Off we go...
}

fn parseArgs(argc: int, argv: pointer) []string {
    args := stringArray(argc, "")
    buf := NewByteBuffer(16)
    for i in 0 .. argc {
        buf.parseCString(argv.inc(i * 8).deref)
        args[i] = buf.toString()
        buf.reset()
    }
    return args
}

fn parseCString(buf: byteBuffer, arg: pointer) {
    off := 0
    while true {
        bytes := arg.inc(off).deref.toTaggedInt()
        b := bytes & 0xFF
        if b == 0x00 {
            return
        }
        buf.append(b)
        off = off + 1
    }
}

fn parseEnv(envp: pointer) env {
    forEach := fn(envp: pointer, f: fn(pointer, int)) int {
        i := 0
        var := envp.inc(i * 8).deref
        while not var.isNull() {
            f(var, i)
            i = i + 1
            var = envp.inc(i * 8).deref
        }
        return i
    }

    // Parse env vars
    n := forEach(envp, fn(arg: pointer, idx: int) {})
    key := stringArray(n, "")
    val := stringArray(n, "")

    buf := NewByteBuffer(16)
    forEach(envp, fn(arg: pointer, idx: int) {
        buf.parseCString(arg)
        s := buf.toString()
        i := s.Index("=") // TODO: Update Index() to support passing a []byte
        if i == -1 {
            key[idx] = s
            val[idx] = ""
        } else {
            key[idx] = buf.substring(0, i)
            val[idx] = buf.substring(i+1, buf.size-i-1) // TODO: Should be calling buf.size()
        }
        buf.reset()
    })
    return Env(key, val)
}

struct env {
    key: []string
    val: []string
}

fn size(e: env) int = e.key.length
fn isSet(e: env, key: string) bool = not e.get(key).Equals("__KEY_NOT_FOUND__")
fn get(e: env, key: string) string {
    for i in 0 .. e.key.length {
        if e.key[i].Equals(key) {
            return e.val[i]
        }
    }
    return "__KEY_NOT_FOUND__" // TODO: This is horrible! We need proper Optional/Maybe support
}

// Called from user code to crash the program
fn panic(cause: string) {
    printf("\n// -----------------------------------------------------------------------------\n")
    printf("// Panic: %s\n", cause)
    printf("// -----------------------------------------------------------------------------\n")
    exit(1)
}

// Invoked by an ASM trampoline (See codegen.go) for invalid array access
fn indexOutOfBounds(index: int, length: int) {
    printf("\n// -----------------------------------------------------------------------------\n")
    printf("// Panic: index out of bounds! index = %d, array.length = %d\n", index, length)
    printf("// -----------------------------------------------------------------------------\n")
    printf("\nBacktrace:\nTODO!\n\n")
    // TODO: Output stacktrace
    exit(1)
}

// ---------------------------------------------------------------------------------------------------------------------

// Runtime representation of a closure
struct closure {
    f: fn(clEnv, int, int, int, int, int) nothing
    env: clEnv
}

struct clEnv {
    // Captured variables ...
}

fn invokeDynamic(p: pointer, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int) {
    if p.isClosure() {
        cl := unsafe(p, 0, type(closure))
        cl.f(cl.env, arg1, arg2, arg3, arg4, arg5)
    } else {
        f := unsafe(p, 0, type(fn(int, int, int, int, int) nothing))
        f(arg1, arg2, arg3, arg4, arg5)
    }
}

// readonly = true ➞ fn pointer, readonly = false ➞ closure
fn isClosure(p: pointer) bool {
    header := p.inc(-8).deref.toRawInt()
    return (header & 0x2) == 0x0
}

// ---------------------------------------------------------------------------------------------------------------------
// External Functions
// ---------------------------------------------------------------------------------------------------------------------

 // Implemented in assembly by codegen.go & called by C main. Invokes entrypoint(int, int, int) defined
 // above. Defined here to prevent redeclares.
fn asm_entrypoint() int

// Source: libc, https://www.gnu.org/software/libc/manual/html_node/Normal-Termination.html#Normal-Termination
fn exit(status: int) nothing

fn getFramePointer() frame // Implemented in assembly by codegen.go
fn isStackBase(f: frame) bool
fn setStackBase(f: frame) nothing

fn setRuntime(r: runtime) nothing
fn getRuntime() runtime

// WARNING: Type system escape hatch! Use with extreme caution!
//
// p: Pointer to heap
// off: Offset from pointer
// _type: Type of return type
// Returns the calculated memory location interpreted as the parameterised type
fn unsafe(p: pointer, off: int, _type: nothing) pointer // Implemented in assembly by codegen.go
