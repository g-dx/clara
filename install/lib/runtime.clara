// Linked List of all stack frames up to stack base
struct frame {
    next: frame
    map: gcMap
}

// GC roots at a particular point in a stack frame
struct gcMap {
    roots: []byte
}

// Runtime information
struct runtime {
    args: []string
    env: env
}

// C -> Clara entrypoint
fn entrypoint(argc: int, argv: int, envp: int) {
    setStackBase(getFramePointer())

    // Configure runtime TODO: GC root tracking for spilled pointers!
    args := parseArgs(argc, argv)
    env := parseEnv(envp)
    setRuntime(Runtime(args, env))

    main() // Off we go...
}

fn parseArgs(argc: int, argv: int) []string {
    args := stringArray(argc, "")
    buf := NewByteBuffer(16)
    i := 0
    while i < argc {
        buf.parseCString(unsafe(argv, i * 8, pointer).deref)
        args[i] = buf.toString()
        buf.reset()
        i = i + 1
    }
    return args
}

fn parseCString(buf: byteBuffer, arg: int) {
    loop := true
    off := 0
    max := 1<<6  // Read bytes in 64-bit blocks
    while loop {
        shift := 0
        bytes := unsafe(arg, off, pointer).deref
        while shift < max and loop {
            b := (bytes >> shift) & 0xFF
            if b == 0x00 {
                loop = false // NUL - end of string
            } else {
                buf.append(b)
                shift = shift + 8
            }
        }
        off = off + 8
    }
}

fn parseEnv(envp: int) env {
    forEach := fn(envp: int, f: fn(int, int)) int {
        i := 0
        var := unsafe(envp, i * 8, pointer).deref
        while not (var == 0) {
            f(var, i)
            i = i + 1
            var = unsafe(envp, i * 8, pointer).deref
        }
        return i
    }

    // Parse env vars
    n := forEach(envp, fn(arg: int, idx: int) {})
    key := stringArray(n, "")
    val := stringArray(n, "")

    buf := NewByteBuffer(16)
    forEach(envp, fn(arg: int, idx: int) {
        buf.parseCString(arg)
        s := buf.toString()
        i := s.Index("=") // TODO: Update Index() to support passing a []byte
        if i == -1 {
            key[idx] = s
            val[idx] = ""
        } else {
            key[idx] = buf.substring(0, i)
            val[idx] = buf.substring(i+1, buf.size-i-1) // TODO: Should be calling buf.size()
        }
        buf.reset()
    })
    return Env(key, val)
}

struct env {
    key: []string
    val: []string
}

fn size(e: env) int = e.key.length
fn isSet(e: env, key: string) bool = not e.get(key).Equals("__KEY_NOT_FOUND__")
fn get(e: env, key: string) string {
    i := 0
    while i < e.key.length {
        if e.key[i].Equals(key) {
            return e.val[i]
        }
        i = i + 1
    }
    return "__KEY_NOT_FOUND__" // TODO: This is horrible! We need proper Optional/Maybe support
}

// Called from user code to crash the program
fn panic(cause: string) {
    printf("\n// -----------------------------------------------------------------------------\n")
    printf("// Panic: %s\n", cause)
    printf("// -----------------------------------------------------------------------------\n")
    exit(1)
}

// Invoked by an ASM trampoline (See codegen.go) for invalid array access
fn indexOutOfBounds(index: int) {
    printf("\n// -----------------------------------------------------------------------------\n")
    printf("// Crash: Index (%d) is out of bounds!\n", index)
    printf("// -----------------------------------------------------------------------------\n")
    printf("\nBacktrace:\nTODO!\n\n")
    // TODO: Output stacktrace
    exit(1)
}

// ---------------------------------------------------------------------------------------------------------------------
// External Functions
// ---------------------------------------------------------------------------------------------------------------------

 // Implemented in assembly by codegen.go & called by C main. Invokes entrypoint(int, int, int) defined
 // above. Defined here to prevent redeclares.
fn asm_entrypoint() int

// Source: libc, https://www.gnu.org/software/libc/manual/html_node/Normal-Termination.html#Normal-Termination
fn exit(status: int) nothing

fn getFramePointer() frame // Implemented in assembly by codegen.go
fn isStackBase(f: frame) bool
fn setStackBase(f: frame) nothing

fn setRuntime(r: runtime) nothing
fn getRuntime() runtime

// WARNING: Type system escape hatch! Use with extreme caution!
//
// ptr: Pointer to heap
// off: Offset from pointer
// type: Type of return type
// Returns the calculated memory location interpreted as the parameterised type
fn unsafe(ptr: int, off: int, type: int) int // Implemented in assembly by codegen.go
