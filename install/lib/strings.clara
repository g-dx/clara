// ---------------------------------------------------------------------------------------------------------------------

struct byteBuffer {
    data: []byte
    size: int
}

// ---------------------------------------------------------------------------------------------------------------------

fn NewByteBuffer(cap: int) byteBuffer = ByteBuffer(byteArray(cap), 0)

fn size(buf: byteBuffer) int = buf.size
fn reset(buf: byteBuffer) { buf.size = 0 }
fn toString(buf: byteBuffer) string = buf.data.toString(buf.size)

// ---------------------------------------------------------------------------------------------------------------------

fn append(buf: byteBuffer, s: string) {
    newSize := buf.size + s.length
    if newSize > buf.data.length {
        buf.grow()
    }
    copyString(s, 0, buf.data, buf.size)
    buf.size = newSize
}

// ---------------------------------------------------------------------------------------------------------------------

fn append(buf: byteBuffer, b: byte) {
    newSize := buf.size + 1
    if newSize > buf.data.length {
        buf.grow()
    }
    buf.data[buf.size] = b
    buf.size = newSize
}

// ---------------------------------------------------------------------------------------------------------------------
// TODO: Should be "private"
fn grow(buf: byteBuffer) {
    data := byteArray(buf.data.length * 2)
    copyArray(buf.data, 0, data, 0)
    buf.data = data
}

// ---------------------------------------------------------------------------------------------------------------------

fn append(s1: string, s2: string) string {
    length := s1.length + s2.length
    bytes := byteArray(length + 1, length) // + 1 for NUL byte
    copyString(s1, 0, bytes, 0)
    copyString(s2, 0, bytes, s1.length)
    return bytes.asString()
}

// ---------------------------------------------------------------------------------------------------------------------

fn copyString(src: string, srcPos: int, dest: []byte, destPos: int) {
    while srcPos < src.length and destPos < dest.length {
        dest[destPos] = src[srcPos]
        srcPos = srcPos+1
        destPos = destPos+1
    }
}

// ---------------------------------------------------------------------------------------------------------------------

fn toString(b: []byte) string {
    return toString(b, b.length)
}

// ---------------------------------------------------------------------------------------------------------------------

fn toString(b: []byte, length: int) string {
    s := byteArray(length + 1, length, 4, "string") // + 1 for NUL byte
    copyArray(b, 0, s, 0)
    return s.asString()
}

// TODO: Should be private!
// NOTE: -8 to offset the +8 which codegen.go adds for arrays/string -> external fns
fn asString(b: []byte) string = unsafe(b, -8, string)