// --------------------------------------------------------------------------------
// Conversions
// --------------------------------------------------------------------------------

fn toByte(i: int) byte = i
fn toBytes(s: string) []byte {
    buf := byteArray(s.length)
    i := 0
    while i < s.length {
        buf[i] = s[i]
        i = i + 1
    }
    return buf
}
fn toBinary(i: int) string {
    buf := NewByteBuffer(78) // 64 digits + 7, 2-byte separators
    j := 63
    digits := "01"
    sep := "Â·"
    while j > -1 { // TODO: Support >= operator
        n := 0
        mask := 1 << j
        if (i & mask) == mask {
            n = 1
        }
        buf.append(digits[n])
        if j > 0 and j.mod(8) == 0 {
            buf.append(sep)
        }
        j = j - 1
    }
    return buf.toString()
}

// --------------------------------------------------------------------------------
// Math
// --------------------------------------------------------------------------------

fn mod(i: int, m: int) int = i - ((i / m) * m)

// --------------------------------------------------------------------------------
// Wrappers
// --------------------------------------------------------------------------------

struct intWrapper { val: int }
fn unwrapInt(w: intWrapper) int = w.val

struct byteWrapper { val: byte }
fn unwrapByte(w: byteWrapper) byte = w.val

struct boolWrapper { val: bool }
fn unwrapBool(w: boolWrapper) bool = w.val

// --------------------------------------------------------------------------------
// Printing
// --------------------------------------------------------------------------------

fn print(s: string) = printf("%s", s)
fn println(s: string) = printf("%s\n", s)
fn println(i: int) = printf("%lli\n", i)
fn println(b: byte) = printf("%hhi\n", b)
fn println(b: bool) = println(b.toString())

// Int
fn printHex(i: int) = printf("0x%llx\n", i)
fn printHexPadded(i: int) = printf("0x%016llx\n", i)

fn toString(b: bool) string = b ? "true" : "false"
fn toString(val: int) string {
    if val == 0 {
        return "0"
    }
    digits := "0123456789"
    // Int min: -9223372036854775808
    // Int max: 9223372036854775807
    buf := byteArray(20)
    base := 10
    n := val
    x := buf.length - 1
    while not (n == 0) {
        quotient := n / base
        buf[x] = digits[val < 0 ? (base * quotient) - n : n - (base * quotient)]
        n = quotient
        x = x - 1
    }
    if val < 0 {
        buf[x] = 0x2d // minus sign
        x = x - 1
    }
    return buf.toString(x+1, buf.length-1-x)
}