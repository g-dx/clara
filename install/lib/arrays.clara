// ---------------------------------------------------------------------------------------------------------------------

fn copyArray(src: bytes, srcPos: int, dest: bytes, destPos: int) {
    if src.length() == srcPos or dest.length() == destPos {
        return
    }
    dest.set(destPos, src.get(srcPos))
    copyArray(src, srcPos+1, dest, destPos+1)
}

// TODO: Should either "any" type or type <T>
fn setElement(src: []int, pos: int, val: int) []int {
    src[pos] = val
    return src
}

// ---------------------------------------------------------------------------------------------------------------------

struct arrayHeader {
    length: int
}

fn stringArray(length: int, default: string) []string {
    h := claralloc((length * 8) + 8, "[]string", 3).toHeader() // int == 8 bytes, + 8 for length
    h.length = length
    a := h.toStringArray()

    // ----------------------------------------------------------------------
    // Initialise contents. This prevents NULL from escaping into user
    // code. Revisit when option/maybe is fully worked out
    // ----------------------------------------------------------------------
    for i in 0 .. a.length {
        a[i] = default
    }
    return a
}

fn intArray(length: int) []int {
    h := claralloc((length * 8) + 8, "[]int", 2).toHeader() // int == 8 bytes, + 8 for length
    h.length = length
    return h.toIntArray()
}

fn toStringArray(header: arrayHeader) []string = unsafe(header, 0, type([]string))
fn toIntArray(header: arrayHeader) []int = unsafe(header, 0, type([]int))
fn toHeader(b: block) arrayHeader = unsafe(b, 0, type(arrayHeader))