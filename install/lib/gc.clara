fn gc() {
    // TODO: Track object live counts & space freed
    debug("gc", "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ GC \n")
    gcMark()
    gcSweep()
    debug("gc", "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n")
}

// Tag-Free Garbage Collection for Strongly Typed Programming Languages
// https://cs.nyu.edu/goldberg/pubs/gold91.pdf
fn gcMark() {
    debug("gc", "ğŸ” Mark:\n")
    fp := getFramePointer()
    roots := fp.map.roots

    j := 0
    while not fp.isStackBase() {
        fp = fp.next
        debug("gc", "\nâ–¶ (%d) <description>", j)
        i := 0
        while i < roots.length {
            gcMarkRoot(fp, roots[i])
            i = i + 1
        }
        roots = fp.map.roots
        j = j + 1
    }
}

struct pointer {
    deref: int
}

struct typeInfo {
    gc: fn(pointer) nothing
}

fn gcMarkRoot(fp: frame, off: byte) {

    // Chase pointers to get block header
    root := unsafe(fp, -off * 8, pointer)
    heapPointer := unsafe(root.deref, -8, pointer)
    blockHeader := heapPointer.deref

    // Get info from header
    id := (blockHeader & 0xFFFF << 48) >> 48
    readOnly := (blockHeader & 0x2) == 0x2

    // Lookup GC tracing function
    info := unsafe(gcTypeTable, id * 8, typeInfo)
    debug("gc", "\n  - 0x%lx, id = %2d, readonly = %d", root.deref, id, readOnly)
    if not readOnly {
        info.gc(root)
    }
}

// http://journal.stuffwithstuff.com/2013/12/08/babys-first-garbage-collector/
fn gcSweep() {
    debug("gc", "\n\nğŸ—‘ï¸ğŸ§¹ Sweep:\n")
    b := getBlocks()
    prev := emptyBlock() // TODO: This is unfortunate! Block.None would be much nicer here!
    while b.isValidBlock() {
        if b.isMarked() {
            b.clearMark()
            prev = b
            b = b.next
        } else {
            unreached := b
            if prev.isValidBlock() {
                prev.next = unreached.next
            } else {
                setBlocks(unreached.next)
            }
            debug("gc", "  - (0x%lx) âœ˜\n", b.inc(16)) // Increment pointer to point to start of user mem
            b = unreached.next
            clarafree(unreached)
        }
    }
}

// Called by the GC when marking a heap address as in use. IMPORTANT: This function cannot allocate!
fn gcMarkType(addr: int, typeDescription: string) {
    if isGcDebug() {
        printf("\n  - (0x%lx) '%s'", addr, typeDescription)
    }
}

fn clearMark(b: block) {
    if not b.isMarked() {
        panic("clearMark() called on unmarked block!")
    }
    b.header = b.header & 0x7FFFFFFFFFFFFFFE
}

fn isMarked(b: block) bool = (b.header & 0x1) == 0x1

// ---------------------------------------------------------------------------------------------------------------------
// External Functions
// ---------------------------------------------------------------------------------------------------------------------
fn isGcDebug() bool
fn isValidBlock(b: block) bool
fn emptyBlock() block

// NOTE: This is not a function! Do not call it! It _should_ be a global symbol.
fn gcTypeTable() nothing