fn gc() {
    // TODO: Track object live counts & space freed
    debug("gc", "──────────────────────────────────────────────────────────────────────────── GC \n")
    gcMark()
    gcSweep()
    debug("gc", "───────────────────────────────────────────────────────────────────────────────\n")
}

// Tag-Free Garbage Collection for Strongly Typed Programming Languages
// https://cs.nyu.edu/goldberg/pubs/gold91.pdf
fn gcMark() {
    debug("gc", "🔎 Mark:\n")
    fp := getFramePointer()
    gc := fp.caller.gc
    while not fp.isStackBase() {
        fp = fp.next
        gc(fp)
        gc = fp.caller.gc
    }
}

// http://journal.stuffwithstuff.com/2013/12/08/babys-first-garbage-collector/
fn gcSweep() {
    debug("gc", "\n🗑️🧹 Sweep:\n")
    b := getBlocks()
    prev := emptyBlock() // TODO: This is unfortunate! Block.None would be much nicer here!
    while b.isValidBlock() {
        if b.isMarked() {
            b.clearMark()
            prev = b
            b = b.next
        } else {
            unreached := b
            if prev.isValidBlock() {
                prev.next = unreached.next
            } else {
                setBlocks(unreached.next)
            }
            debug("gc", "  - (0x%lx) ✘\n", b.inc(16)) // Increment pointer to point to start of user mem
            b = unreached.next
            clarafree(unreached)
        }
    }
}

fn noGc() nothing {
    // Called by the GC when tracing a GC root which is not in the heap (integers, bools, etc)
}

// Called by the GC when starting to trace a frame. IMPORTANT: This function cannot allocate!
fn gcTraceFrame(fnDescription: string) {
    if isGcDebug() {
        printf("\n%s\n", fnDescription)
    }
}

// Called by the GC when marking a heap address as in use. IMPORTANT: This function cannot allocate!
fn gcMarkType(addr: int, typeDescription: string) {
    if isGcDebug() {
        printf("  - (0x%lx) '%s' \n", addr, typeDescription)
    }
}

// TODO: this function _should_ be clearing bits in header!
fn clearMark(b: block) {
    if b.header == 1 {
        b.header = 0
    }
}

// TODO: This function _should_ be checking bit in header!
fn isMarked(b: block) bool {
    return b.header == 1 // GC marked it
}

// ---------------------------------------------------------------------------------------------------------------------
// External Functions
// ---------------------------------------------------------------------------------------------------------------------
fn isGcDebug() bool
fn isValidBlock(b: block) bool
fn emptyBlock() block