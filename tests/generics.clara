fn main() {

    // Type parameters bound by callsite
    apply(999, fn(i: int) bool = i > 10).println() // EXPECT: true
    apply("Helloworld", fn(s: string) int = s.length).println() // EXPECT: 10
    false.apply(fn(b: bool) string = b.toString()).println() // EXPECT: false

    e := Employee("Some Body", 61, false, Address(1, "Street", "City", "SW1 3DL"))
    e.apply(fn(e: employee) bool = e.retired).println() // EXPECT: false

    // Explicit type parameters
    e.apply«employee, address»(fn(e: employee) address = e.addr).city.println() // EXPECT: City

    // Output parameter required
    // TODO: Re-enable after unsafe actually has the type(R) tag passed to it!
//    cast«int, bool»(1).println() // EXPECT: true

    // ------------------------------------------------------------------
    // Boxing/Unboxing

    // No boxing
    identity("No boxing").println() // EXPECT: No boxing

    // Primitive boxed arg & unboxed return primitive
    identity(10).println() // EXPECT: 10

    // Function boxed arg & boxed return function
    identity(fn(i: int) bool = i > 5)(10).println() // EXPECT: true

    // Primitive boxed arg & boxed closure
    closure(12345678)().println() // EXPECT: 12345678

    // Complex function boxed arg & unboxed primitive return
    apply2(10, fn(i: int) fn(int) bool {
        return fn(i: int) bool = i > 5
    }).println() // EXPECT: true
}

fn identity«T»(t: T) T {
    gc()
    return t
}

fn closure«T»(t: T) fn() T {
    return fn«T»() T = identity(t) // TODO: We shouldn't have to declare T again here
}

fn apply2«T, R»(t: T, f: fn(T) fn(T) R) R {
    tmp1 := f(t)
    tmp2 := tmp1(t)
    return tmp2
}

fn apply«T, R»(t: T, f: fn(T) R) R = f(t)
fn cast«T, R»(t: T) R = unsafe(t, 0, type(R))

struct employee {
    name: string
    age: int
    retired: bool
    addr: address
}

struct address {
    houseNumber: int
    street: string
    city: string
    postcode: string
}